es写流程：客户端（发送请求）->协调节点（对document路由转发）->对应node（有primary shard，primary shard处理请求并同步数据到replica node）->协调节点发现primary node和replica node均成功则返回结果给客户端；
es读流程：客户端（发送请求）->协调节点（doc id hash操作，路由转发）->从primary shard和所有replica中随机选择一个（随机轮询）实现读操作负载均衡->返回document给协调节点->协调节点返回给客户端；
es搜索流程（全文搜索）：客户端（发送请求）->协调节点（路由转发）->所有shard对应的primary shard或replica node->shard将搜索结果（doc id集合）返回给协调节点->协调节点合并、排序、分页 + 去各节点拉取document并返回客户端；
es删除操作：doc标记为deleted状态，合并segment file的时候才会执行物理删除；
总结：写操作是写入primary shard并同步到replica node，读操作则是采用随机轮询的策略从primary shard或者replica node读取；
写操作执行细节：先写入内存buffer（buffer里面的数据搜索不到），每隔1s触发refresh（buffer写入到os cache，然后再写到segment file），buffer里面的数据每隔5秒写入到translog；
translog达到一定阈值/每隔30分钟触发flush（缓冲区文件全部写入到segment file + 清空translog重启一个tanslog）；
es是准实时的解释：写入的数据1秒后才可以看到；
es宕机可能会有5秒钟的数据丢失；
lucene：就是一个jar包，里面封装好了各种建立倒排索引的算法代码；
es搜索引擎中，每个文档都有一个对应的文档ID，文档内容被表示为一系列关键词的集合，每个关键词都会记录它在文档中出现的次数和位置；
倒排索引：关键词到文档ID的映射。特点：1）倒排索引中的所有词项对应一个或多个文档；2）倒排索引中的词项根据字典顺序升序排列；
非结构化数据搜索方法（如文档、图片和视频）：顺序扫描（低效）、全文检索（提取信息（索引）结构化，加快搜索速度）；
基于Lucene实现全文检索引擎，采用了倒排索引（创建一个包含所有不重复词条（term）的排序列表（字典，term排序便于二分法查找），然后列出词条出现在哪个文档（倒排文件））；
分布式（不依赖第三方，如zookeeper）实时文档存储、分析搜索引擎；
发现模块：Zen Discovery，用于将相同名字的节点连接成一个集群，用于选择master节点；
节点可以设置为是否为候选主节点（用于创建索引、删除索引、管理其他节点）、数据节点，节点最好不要同时为主节点和数据节点；
脑裂问题：集群中出现多个主节点（一般是误判主节点挂了），避免方式：1）适当调大响应时间，减少误判；2）角色分离；3）选举触发；
解决数量大的方式：分片（分片数量不能修改）；
副本：副本就是对分片的copy，每个主分片（文档的新建、索引和删除请求都必须在主分片上进行（乐观锁实现），成功后同步到副本分片）都有一个或者多个副本分片；
同时支持静态义映射（创建时定义类型，推荐）和动态映射（创建时不指定，可以自动识别但不够精确）；
查找分片方式：hash值 % 分片数量；
更新=删除+新增操作；
segment合并的时候会真正删除标记删除的数据；
es搜索：同一个shard里面的segments搜索结果汇聚，shard（可能在不同节点，涉及网络传输）搜索结果汇聚；
es查的是文档（Document）；
倒排索引：以内容作为索引，以文档id作为记录；
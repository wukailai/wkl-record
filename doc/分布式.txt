分布式事务背景：每个服务都有自己的数据源；
CAP理论：web服务无法同时满足以下三个属性不过：
    1）数据一致性（分强一致性、弱一致性（允许部分数据不一致）、最终一致性（允许中间阶段数据不一致），最容易被抛弃）：客户端知道一系列的操作都会同时发生(生效)；
    2）可用性（有限时间响应）：每个操作都必须以可预期的响应结束；
    3）分区容错性（最不能被抛弃，因为网络问题是分布式系统必定会出现的问题）：即使出现单个组件无法可用，操作依然可以完成；
目前主流分布式解决方案：基本可用 + 软状态 + 最终一致性；
常见的分布式事务解决方案：MQ、LCN、Seata、2PC（两阶段提交）、3PC（三阶段提交）；
两阶段提交：
    1）第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交；
    2）第二阶段：事务协调器要求每个数据库提交数据；
两阶段提交问题：
    1）同步阻塞；
    2）单点故障；
    3）数据不一致；
三阶段提交阶段（引入了超时机制）：CanCommit、PreCommit（其中一个超时或者执行失败，则TM发起中断）和doCommit；
三阶段提交特点：优点是引入了超时机制，降低了阻塞范围，缺点是可能会造成数据不一致；
TCC（保证最终一致性）三阶段：Try、Confirm、Cancel；
TCC严重依赖回滚和代码补偿，采用的是先提交后修正的思想；
Seata由三部分组成：TC（事务协调器）、TM（事务管理器）、RM（资源管理器）；
Seata解决分布式事务关键因素：
    1）全局事务id，存入发起方、参与方ThreadLocal；
    2）发起方、参与方数据源的前置镜像和后置镜像写入undo log；
    3）事务协调器管理所有分支，异常或者超时通知所有分支利用undo log回滚；
消息队列解决方案：
    1）A系统先发送一个prepared消息到mq，如果这个prepared消息发送失败那么就直接取消操作别执行了；
    2）如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉mq发送确认消息，如果失败就告诉mq回滚消息；
    3）如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
    4）mq会自动定时轮询所有prepared消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了；
    5）这个方案里，要是系统B的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿；
MQ最大努力通知方案：
    1）系统A本地事务执行完之后，发送个消息到MQ；
    2）这里会有个专门消费MQ的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统B的接口；
    3）要是系统B执行成功就ok了；要是系统B执行失败了，那么最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行就放弃；
RocketMQ实现了分布式事务框架，最终一致性方案；
TCC和可靠消息最终一致性方案是在生产中最常用，TCC用于强一致主要用于核心模块，例如交易/订单等。最终一致方案一般用于边缘模块例如库存；
大量的close_wait可能会导致端口被大量占用（TCP端口上限65535）；
close_wait作用：ACK重发；
服务器端主动关闭tcp连接的情况：http头部的connection参数为false，而不是keep-alive；
正向代理：VPN，代理的是客户端；反向代理：Nginx，代理的是服务器；
反向代理Ngnix作用：1）负载均衡；2）安全控制；3）缓存静态文件；
服务器在HTTP头里设置sessionId，客户端则将sessionId保存在cookie里面；
分布式系统session保存方案：session存放在redis中；
差错检测两种实现：1）奇偶校验；2）循环冗余校验；
IP寻址流程：先找到网络号，然后通过ARP将IP地址转化成MAC地址进行查询；
流量控制：动态控制发送端滑动窗口的大小；
DHCP：动态分配IP地址；
httpClient可以对每个请求设置不同的超时时间，OKHttp一旦设置了超时时间所有请求的超时时间也就确定了；
单例模式下，HttpClient性能更好，非单例模式下，OKHttp性能更佳；
SSL证书由权威机构颁发，服务器想要使用SSL的话需要通过权威机构来签发证书；
对证书的校验：获取上级证书 => 上级证书公钥对证书指纹解密得到签名1 => 通过签名算法计算出签名2 => 对比签名1和签名2证明证书是否被篡改；
大多数浏览器限定url2K字节，服务器最多处理64K大小的url；
GET产生一个TCP数据包，POST产生两个TCP数据包；
预防SYN攻击方式：1）缩短超时、2）增加最大半连接数；3）cookie技术；4）网关过滤；
cookie（键值对数据格式）不可跨域，但是可以通过domain（指定cookie所属域名）实现一级域名和二级域名之间共享cookie；
session基于cookie实现，sessionId会被存储在cookie中；
token（有签名，可存放于cookie中，发送给服务器时存放于Header中，服务器不存放token，移动端用的多）：访问资源接口（API）时所需要的资源凭证；
JWT（与token一样，都是访问资源的令牌，都使服务器无状态化，jwt可以存储额外信息，减少服务器查询数据库）：不需要担心跨域资源共享问题，
    1）放在HTTP请求头信息的Authorization字段里；
    2）放在post请求的数据体里面；
    3）get请求url参数里面；
分布式session解决方案：
    1）session复制；
    2）绑定策略，ip进行hash，固定ip的session存储在指定机器上；
    3）session共享（redis）；
    4）session持久化；
JWT = HEADER（记录元数据信息，如签名算法、令牌类型） + PAYLOAD（标准声明、公共声明、私有声明） + SIGNATURE（对前面两部分的签名，防止数据篡改）；
服务端通过客户端传入的随机数构造对称加密算法对后面传输的内容进行加密；
利用根证书（一般浏览器内置）对证书进行校验；
cookie无法跨域；
tomcat用多个不同的自定义类加载器加载不同的web项目，打破了双亲委派；
跨域三种解决方式：
    1）配置类（@Configuration修饰的类）实现WebMvcConfigurer接口，全局生效；
    2）配置类（@Configuration、@WebFilter(filterName = "CorsFilter ")修饰的类）实现Filter接口，全局生效；
    3）@CrossOrigin注解：示例@CrossOrigin(origins = "http://localhost:4000")，单个请求生效；
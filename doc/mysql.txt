count(1)、count(字段)、count(*)的区别：count(1)、count(*)会算上null的记录，count(字段)不会算上null的记录；
执行效率：count(主键列) > count(1) > count(非主键列) && count(*)；
mysql优化小手段：
    1）使用exists、not exist代替in和not in；
    2）尽量不使用like语句；
    3）where条件中避免对字段进行函数操作；
    4）允许脏读可以预防查询被更新事务阻塞；
    5）尽量少用text，非用不可最好分表处理（单独放入一张表）；
    6）大语句拆小语句；
    7）使用同类型进行比较，比如用'123'和'123'比，123和123比；
    8）join代替子查询，因为子查询会创建临时表从而带来额外的开销；
    9）使用Explain和Describe分析sql语句执行信息；
    10）中间表、冗余字段从而减少连接查询；
    11）优化数据库参数；
insert into table_a select * from table_b where condition > 1;隐患：table_a加表锁，table_b逐步锁（扫描一个锁一个，锁的数据越来越多）；
解决办法：条件判断字段condition加索引，避免全表扫描而锁表；
OLAP：仓库型数据库，主要是读取数据，做复杂的数据分析；
OLTP：传统的关系型数据库，强调事务一致性；
在where不满足条件的情况下，count(*)、sum(*)也有可能返回null；
limit可以较大提升性能；
linux连远端数据库（指定端口，非3306）指令：mysql -hip -Pport -uuser -ppassword；
mysql limit会让null最先显示；
limit起始位置越大，速度越慢，优化思路：选择自增id作为列，记录上一次limit位置，从这个位置开始下一次的limit读取；
select(*)效率低的原因：
    1）不需要的列会增加数据传输时间和网络开销（数据库列越多，消耗越大）；
    2）对于无用的大字段，如varchar、text，会增加io操作；
    3）失去”覆盖索引“策略优化的可能性；
    4）增加查询分析器解析成本；
覆盖索引直接读内存，而且不需要第二次查找；
联合索引(a,b,c)实际建立了(a)、(a,b)、(a,b,c)三个索引；
主键自增缺点：
    1）不安全；
    2）高并发场景下锁竞争；
顺序写比随机写要快400倍；
mysql redo日志：数据修改写入redo日志，这样即使宕机也可以快速恢复数据；
顺序访问要比随机访问（IO次数会多很多）要快很多；
not in：先计算子查询，再计算外查询，双层遍历做筛选；
exists：遍历外查询，每次遍历判断内表是否符合匹配条件，符合则加入返回集合中；
not in需要保证子查询的匹配字段都是非空的，否则会返回空集合；
not in对内外表都需要扫描，没有用到索引；
in适合外表大、内表小，exists适合外表小、内表大；
exists返回的是一个Boolean值，不关心返回的具体数据是什么；
select * from t1 where not exists (select name from t2 where t1.name=t2.name)可以优化为
select * from t1 where not exists (select 1 from t2 where t1.name=t2.name)，因为1>column>*；
select *会等价于查找所有字段；
对于exists来说，外表总是会执行全扫描，不会走索引，外表应该选小表；
不用null的原因：
    1）很难做查询优化；
    2）需占用额外的索引空间；
避免在where后面进行null值判断，否则会导致引擎放弃使用索引；
MyISAM支持全文索引，支持延迟更新索引，极大提升写入效率，InnoDB不支持全文索引；
mysql数据最终是保存在数据页中的，物理日志记录的就是数据页的变更；
WAL（Write-Ahead Logging）：先写日志，再写磁盘；
二进制日志：binlog
    1）记录数据库执行的写入性操作信息（就是sql语句），以追加的方式写入，以二进制的方式保存在磁盘中；
    2）使用场景：主从复制（master向slave发送binlog）、数据恢复；
    3）对于Innodb，只有事务提交时才会记录binlog；
事务日志：
    1）redo log；
        a）记录了事务对数据页做了哪些修改；
        b）分为两部分：内存中的日志缓冲和磁盘上的日志文件；
    2）undo log；
        a）记录了数据的逻辑变化，比如一条insert语句对应一条delete语句，回滚时使用；
SQL注入：传参当成执行语句一部分，如参数传' or '1'='1，这样name='${name}' <=> name='' or '1'='1'；
读未提交：读操作不加锁；读已提交：读操作加锁，且执行完读操作后立即释放锁；
可重复读：读操作加锁，且执行完事务后才释放锁；串行化：表锁，事务完成后释放锁；
行级锁：并发度高、但是加锁慢，开销大，有死锁风险，基于索引实现行锁；
页级锁：介于行级锁和表级锁之间，折中策略；
共享锁（读读不互斥）和排他锁
InnoDB存储引擎的锁的算法有三种
    1.Record lock：单个行记录上的锁
    2.Gap lock：间隙锁，锁定一个范围，不包括记录本身--阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
    3.Next-key lock：record+gap 锁定一个范围，包含记录本身
基础表、派生表（查询结果、临时表）、虚拟表（视图）；
turncate效率远高于delete，而且不走事务、不会锁表，也不会生产大量日志写入日志文件，立刻释放磁盘空间并重置auto_increment值；
delete会将所有涉及的行加写锁和Gap锁（where字段加了索引的情况下）；
加锁都是基于索引的，如果字段没有索引，就会扫描到主键索引上；
DELETE：假删除，仅仅给被删除数据打上已删除标记，因此磁盘存储空间不会被释放（除非使用optimize table table_name），下次插入数据时，可重用已删除空间；
TRUNCATE：不走事务；不触发trigger，立刻释放磁盘空间，执行后数据无法找回，等价于drop + create操作，会重置auto_increment；
drop：立即释放磁盘空间，执行后数据无法找回；

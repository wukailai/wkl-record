count(1)、count(字段)、count(*)的区别：count(1)、count(*)会算上null的记录，count(字段)不会算上null的记录；
执行效率：count(主键列) > count(1) > count(非主键列) && count(*)；
mysql优化小手段：
    1）使用exists、not exist代替in和not in；
    2）尽量不使用like语句；
    3）where条件中避免对字段进行函数操作；
    4）允许脏读可以预防查询被更新事务阻塞；
insert into table_a select * from table_b where condition > 1;隐患：table_a加表锁，table_b逐步锁（扫描一个锁一个，锁的数据越来越多）；
解决办法：条件判断字段condition加索引，避免全表扫描而锁表；
OLAP：仓库型数据库，主要是读取数据，做复杂的数据分析；
OLTP：传统的关系型数据库，强调事务一致性；
在where不满足条件的情况下，count(*)、sum(*)也有可能返回null；
limit可以较大提升性能；
linux连远端数据库（指定端口，非3306）指令：mysql -h ip -P port -u user -p password；
mysql limit会让null最先显示；
limit起始位置越大，速度越慢，优化思路：选择自增id作为列，记录上一次limit位置，从这个位置开始下一次的limit读取；
select(*)效率低的原因：
    1）不需要的列会增加数据传输时间和网络开销（数据库列越多，消耗越大）；
    2）对于无用的大字段，如varchar、text，会增加io操作；
    3）失去”覆盖索引“策略优化的可能性；
    4）增加查询分析器解析成本；
覆盖索引直接读内存，而且不需要第二次查找；
联合索引(a,b,c)实际建立了(a)、(a,b)、(a,b,c)三个索引；